#include "HeadedBitset.hpp"ChunkUniqueID HeadedBitset::GetHead(){    return head;}void HeadedBitset::SetHead(ChunkUniqueID newHead){    head = newHead;}/*Converte um inteiro, para o seu equivalente em binário na estrutura de dadosdynamic_bitset*//*boost::dynamic_bitset<> Client::ByteToBitset(uint8_t a){    boost::dynamic_bitset<> x;        while (a >= 1)    {        x.push_back(a%2);        a = a/2;                    }    if (a == 1)        x.push_back(1);        return x;}*//*Retorna um vetor de unsigned chars  contendo o número binário do parametro "a"Cada caracter no vetor representa 8 bits *//*uint8_t* Client::BitsetToBytes(boost::dynamic_bitset<> a){    unsigned char *c;    c = new unsigned char [a.size()/8 + a.size()%8];    unsigned int i;    int j;    boost::dynamic_bitset<> x(8);    j = 0;    for (i = 0; i < a.size(); i++)    {        x[i%8] = a[i];        if (i%8 == 7)        {            c[j] = x.to_ulong();            j++;        }    }        while (i%8 != 0)    {         //Preenche com zero os bits que sobram no ultimo caracter        x[i%8] = 0;        i++;        if (i%8 == 7)        {            c[j] = x.to_ulong();            j++;        }    }    return c;}*/std::ostream& operator<<(std::ostream& os, const HeadedBitset& bitset){    os << "Map[" << bitset.head << "]" << endl;    for (uint32_t i = 0; i < bitset.size(); i++)    {        if (i%10 == 0) os << i/10 << "[" ;        os << (int)bitset[i];        if (i%10 == 9) os << "]"<< endl;    }    return os;}